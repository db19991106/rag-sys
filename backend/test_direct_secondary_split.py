from services.chunker import Chunker

# 创建切分器实例
chunker = Chunker()

# 创建包含长内容的测试文档，确保使用明确的论文结构
test_content = '''# 测试文档：二次拆分功能验证

## 第一章 引言
这是测试文档的引言部分，简短介绍二次拆分的目的和重要性。

## 第二章 二次拆分原理
二次拆分是一种基于子标题层级结构的精细化拆分技术，用于解决智能拆分后可能出现的超长片段问题。它能够识别文档的子标题结构，并基于这些结构进行更精细的拆分，同时确保每个拆分单元的字符数量控制在合理范围内。

### 2.1 子标题检测
子标题检测是二次拆分的第一步，它通过分析文档的格式和结构来识别不同层级的标题。常见的子标题格式包括：

1. Markdown 格式：使用 ##、### 等标记表示不同层级的标题。
2. 数字编号格式：使用 1.1、1.2.3 等数字编号表示层级关系。
3. 中文编号格式：使用 一、二、三等中文数字表示主要章节，(一)、(二)等表示次要章节。
4. 其他格式：如使用特定的前缀或格式标记标题。

子标题检测的准确性直接影响后续拆分的效果，因此需要综合考虑多种格式和模式。

### 2.2 基于子标题的切分
基于检测到的子标题，二次拆分系统会执行以下步骤：

1. 以子标题为边界，将原始内容初步拆分为多个单元。
2. 检查每个初步拆分单元的字符数量，如果超过预设的阈值，则进行进一步的拆分。
3. 对于仍然超长的单元，基于段落进行更精细的拆分，确保每个最终拆分单元的字符数量在合理范围内。
4. 保存每个拆分单元，确保标题与内容的完整性和关联性。

### 2.3 字符数量控制
字符数量控制是二次拆分的核心目标之一，它确保每个拆分单元的字符数量不超过预设的阈值：

- 最大字符数阈值：单个单元字符数不超过2000。
- 推荐字符数上限：单个单元字符数不超过1500。

通过严格的字符数量控制，二次拆分能够确保每个拆分单元都可以作为独立完整的信息模块使用，同时避免了超长片段带来的处理效率和信息提取问题。

## 第三章 二次拆分的质量保证
为了确保二次拆分的质量，系统采取了多种措施：

### 3.1 内容完整性
内容完整性是二次拆分的首要保证，系统通过以下方式确保所有原始内容都被准确分配：

1. 完整保留所有子标题文本及其对应的全部内容信息。
2. 确保标题与内容的关联性完整无缺。
3. 在拆分完成后进行完整性校验，确认所有原始内容均被准确分配至相应拆分单元。

### 3.2 结构维持
结构维持确保原始内容的逻辑组织结构、段落顺序及信息层级关系不被破坏：

1. 严格保持原始内容的逻辑组织结构。
2. 维持原始的段落顺序。
3. 保留原始的信息层级关系。
4. 不得擅自调整内容顺序或层级。

### 3.3 质量验证
质量验证是确保二次拆分效果的重要环节，包括以下方面：

1. 字符数量验证：确保每个拆分单元的字符数量在合理范围内。
2. 内容完整性验证：确保所有原始内容都被准确分配，无遗漏或重复。
3. 结构完整性验证：确保原始内容的逻辑结构和层级关系得到保持。
4. 上下文连续性验证：确保拆分单元之间的上下文连续性，避免信息断裂。

## 第四章 实验结果与分析
通过对多种类型文档的测试，二次拆分功能展现了良好的性能：

### 4.1 字符数量控制效果
测试结果表明，二次拆分能够有效控制拆分单元的字符数量：

- 95%以上的拆分单元字符数量在1500以内。
- 100%的拆分单元字符数量在2000以内。
- 拆分单元的平均字符数量约为1000，符合推荐的合理范围。

### 4.2 内容完整性保证
内容完整性测试结果：

- 所有测试文档的内容完整性均达到98%以上。
- 无明显的内容丢失或重复现象。
- 标题与内容的关联性得到完整保留。

### 4.3 结构维持效果
结构维持测试结果：

- 所有测试文档的逻辑结构和层级关系得到完整保持。
- 段落顺序和信息流程未被破坏。
- 拆分单元的组织结构清晰合理。

## 第五章 结论与展望
二次拆分功能的实现为文档切分系统提供了一种有效的解决方案，能够解决智能拆分后可能出现的超长片段问题。

### 5.1 主要贡献
1. 实现了基于子标题层级结构的精细化拆分技术。
2. 提供了严格的字符数量控制机制，确保每个拆分单元的字符数量在合理范围内。
3. 保证了内容的完整性和结构的维持，避免了内容割裂和信息丢失。
4. 建立了完善的质量验证机制，确保拆分效果的可靠性。

### 5.2 未来改进方向
1. 进一步提高子标题检测的准确性，支持更多类型的标题格式。
2. 优化拆分算法，提高处理效率和拆分质量。
3. 研究语义感知的拆分技术，进一步提高拆分的智能化水平。
4. 开发用户友好的配置界面，允许用户根据具体需求调整拆分参数。

通过不断的改进和优化，二次拆分技术将在文档处理、信息提取、知识管理等领域发挥越来越重要的作用。
'''

# 直接测试二次拆分功能
print("开始测试二次拆分功能...")
print(f"原始内容字符数: {len(test_content)}")

# 执行二次拆分
secondary_chunks = chunker._secondary_split(
    test_content,
    max_char_count=2000,
    recommended_max=1500
)

# 输出结果
print(f"\n二次拆分完成，生成了 {len(secondary_chunks)} 个片段")
print("\n片段详情：")
for i, chunk in enumerate(secondary_chunks):
    print(f"\n片段 {i+1}:")
    print(f"字符数: {len(chunk)}")
    print(f"内容前100字符: {chunk[:100]}...")

# 验证字符数量控制
print("\n\n字符数量控制验证：")
over_2000 = [i for i, c in enumerate(secondary_chunks) if len(c) > 2000]
over_1500 = [i for i, c in enumerate(secondary_chunks) if len(c) > 1500]

print(f"超过2000字符的片段数量: {len(over_2000)}")
print(f"超过1500字符的片段数量: {len(over_1500)}")
print(f"所有片段字符数均在合理范围内: {len(over_2000) == 0}")

# 验证内容完整性
total_characters = sum(len(c) for c in secondary_chunks)
original_characters = len(test_content.strip())
print(f"\n\n内容完整性验证：")
print(f"原始内容字符数: {original_characters}")
print(f"拆分后总字符数: {total_characters}")
print(f"内容完整性: {'完整' if abs(original_characters - total_characters) < 100 else '可能存在丢失'}")
print(f"字符数差异: {abs(original_characters - total_characters)}")

# 验证结构维持
print("\n\n结构维持验证：")
# 检查是否包含所有标题
all_headings = ['# 测试文档', '## 第一章', '## 第二章', '### 2.1', '### 2.2', '### 2.3', '## 第三章', '### 3.1', '### 3.2', '### 3.3', '## 第四章', '### 4.1', '### 4.2', '### 4.3', '## 第五章', '### 5.1', '### 5.2']

missing_headings = []
for heading in all_headings:
    found = any(heading in chunk for chunk in secondary_chunks)
    if not found:
        missing_headings.append(heading)

if missing_headings:
    print(f"缺失的标题: {missing_headings}")
else:
    print("所有标题均已保留")

print("\n二次拆分功能测试完成！")
